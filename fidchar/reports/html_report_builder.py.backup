#!/usr/bin/env python3
"""HTML comprehensive report builder module.

Handles the creation of comprehensive HTML reports with all sections.
Uses Bootstrap CSS and report_generator renderers for cleaner code.
"""

import pandas as pd
from datetime import datetime
from fidchar.reports import base_report_builder as brb
from fidchar.reports import html_templates as templates
from fidchar.core import analysis as an
from fidchar.report_generator.models import ReportTable, ReportCard, CardSection
from fidchar.report_generator.renderers import HTMLSectionRenderer, HTMLCardRenderer
import shutil
import os

def _extract_section_options(section):
    """Extract options from section config, supporting both nested and flat structure.
    """
    if not isinstance(section, dict):
        return {}

    # If there's an explicit 'options' key, use it
    if 'options' in section:
        return section.get('options', {})

    # Otherwise, treat all keys except 'name' as options (flat structure)
    return {k: v for k, v in section.items() if k != 'name'}


class HTMLReportBuilder(brb.BaseReportBuilder):
    """HTML report builder with inherited state."""

    def __init__(self, df, config, report_data):
        super().__init__(df, config, report_data)
        self.table_renderer = HTMLSectionRenderer()
        self.card_renderer = HTMLCardRenderer()

    def generate_html_header_section(self, options=None):
        """Generate the custom header and executive summary sections for fidchar report.
         """
        options = options or {}
        show_one_time = options.get('show_one_time', True)
        show_stopped = options.get('show_stopped', True)

        # If all subsections are disabled, suppress the entire section
        if not show_one_time and not show_stopped:
            return ""

        # Calculate statistics from instance data
        total_donations = len(self.df)
        years_covered = f"{self.df['Year'].min()} - {self.df['Year'].max()}"

        # Build cards HTML based on options (using precomputed instance variables)
        cards_html = ""
        if show_one_time:
            cards_html += f"""
            <div class="col-md-3">
                <div class="card border-start border-4 border-primary">
                    <div class="card-body">
                        <h6 class="card-title">One-Time Donations</h6>
                        <p class="card-text"><strong>{self.one_time_count} organizations</strong></p>
                        <p class="card-text">Total: ${self.one_time_total:,.2f}</p>
                    </div>
                </div>
            </div>"""

        if show_stopped:
            cards_html += f"""
            <div class="col-md-3">
                <div class="card border-start border-4 border-warning">
                    <div class="card-body">
                        <h6 class="card-title">Stopped Recurring</h6>
                        <p class="card-text"><strong>{self.stopped_count} organizations</strong></p>
                        <p class="card-text">Total: ${self.stopped_total:,.2f}</p>
                    </div>
                </div>
            </div>"""

        # Only show row if we have cards to display
        cards_section = f"""
        <div class="row mb-5">
{cards_html}
        </div>""" if cards_html else ""

        return f"""    <div class="report-section section-header">
        <header class="text-center mb-5 pb-3 border-bottom">
            <h1 class="display-4">Charitable Donation Analysis Report</h1>
            <p class="text-muted">Generated on {datetime.now().strftime('%B %d, %Y at %I:%M %p')}</p>
            <div class="alert alert-light border">
                <strong>Total Donations:</strong> {total_donations:,} donations |
                <strong>Total Amount:</strong> ${self.total_amount:,.2f} |
                <strong>Years Covered:</strong> {years_covered}
            </div>
        </header>
{cards_section}
    </div>"""

    def _build_html_document(self, custom_header, custom_footer):
        """Build a complete HTML document with Bootstrap CSS.

        Uses instance configuration for document title, CSS files, and container class.

        Args:
            custom_header: HTML content for header section
            custom_footer: HTML content for footer section

        Returns:
            Complete HTML document string
        """
        # Document configuration (constant for this report type)
        doc_title = "Charitable Donation Analysis Report"
        container_class = "container"
        css_files = ["colors.css", "styles.css"]

        # Build CSS links for external files
        css_links = ""
        for css_file in css_files:
            css_links += f'  <link rel="stylesheet" href="{css_file}">\n'

        header_block = custom_header if custom_header else ""
        footer_block = custom_footer if custom_footer else ""

        return f"""<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>{doc_title}</title>
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/css/bootstrap.min.css" rel="stylesheet">
{css_links}</head>
<body class="small">
<div class="{container_class}">
{header_block}
{footer_block}
</div>
<script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/js/bootstrap.bundle.min.js"></script>
</body>
</html>"""

    def _render_two_column_table(self, df_data, title=None):
        """Render DataFrame data as two-column layout for print.

        Args:
            df_data: List of dictionaries to convert to DataFrame
            title: Optional title to display above the columns

        Returns:
            HTML string with two-column table layout
        """
        mid_point = (len(df_data) + 1) // 2
        df_left = pd.DataFrame(df_data[:mid_point])
        df_right = pd.DataFrame(df_data[mid_point:])

        table_left = ReportTable.from_dataframe(df_left, title=None)
        table_right = ReportTable.from_dataframe(df_right, title=None)

        left_html = self.table_renderer.render(table_left)
        right_html = self.table_renderer.render(table_right)

        columns_html = f"""
        <div class="row">
            <div class="col-md-6">{left_html}</div>
            <div class="col-md-6">{right_html}</div>
        </div>
        """

        if title:
            return f"""
        <h2 class="mb-3">{title}</h2>
{columns_html}"""
        else:
            return columns_html

    def generate_top_charities_bootstrap(self, charities):
        """Generate charities table using Bootstrap renderer - two columns for print"""
        # Build DataFrame with formatted org names that include badges
        df_data = []
        for ein, row in charities.iterrows():
            # Get formatted org name with badges
            charity_info = self.format_charity_info(ein, row['Organization'], row['Amount_Numeric'])

            df_data.append({
                'Organization': charity_info['html_org'],
                'Total Amount': f"${row['Amount_Numeric']:,.0f}"
            })

        return self._render_two_column_table(
            df_data,
            title=f"Charities by Total Donations ({len(charities)} charities)"
        )

    def generate_category_table_bootstrap(self, category_totals, total_amount, show_percentages=False):
        """Generate category totals table using Bootstrap renderer"""
        df = category_totals.reset_index()
        df.columns = ['Charitable Sector', 'Total Amount']

        if show_percentages:
            df['Percentage'] = (df['Total Amount'] / total_amount * 100).apply(lambda x: f"{x:.1f}%")

        df['Total Amount'] = df['Total Amount'].apply(lambda x: f"${x:,.0f}")

        table = ReportTable.from_dataframe(
            df,
            title="Donations by Charitable Sector"
        )
        return self.table_renderer.render(table)

    def generate_yearly_table_bootstrap(self, yearly_amounts, yearly_counts):
        """Generate yearly analysis table using Bootstrap renderer"""
        df = pd.DataFrame({
            'Year': sorted(yearly_amounts.index),
            'Total Amount': [f"${yearly_amounts[year]:,.0f}" for year in sorted(yearly_amounts.index)],
            'Number of Donations': [yearly_counts[year] for year in sorted(yearly_amounts.index)]
        })

        table = ReportTable.from_dataframe(
            df,
            title="Yearly Analysis"
        )
        return self.table_renderer.render(table)

    def generate_one_time_table_bootstrap(self, one_time, max_shown=20):
        """Generate one-time donations table using Bootstrap renderer - two columns for print"""
        # Build DataFrame with formatted org names that include badges
        df_data = []
        for ein, row in one_time.head(max_shown).iterrows():
            # Get formatted org name with badges
            charity_info = self.format_charity_info(ein, row['Organization_Name'], row['Total_Amount'])

            df_data.append({
                'Organization': charity_info['html_org'],
                'Amount': f"${row['Total_Amount']:,.2f}",
                'Date': row['First_Date'].strftime("%m/%d/%Y")
            })

        return self._render_two_column_table(
            df_data,
            title=f"One-Time Donations ({len(one_time)} organizations)"
        )

    def generate_stopped_table_bootstrap(self, stopped_recurring, max_shown=15):
        """Generate stopped recurring table using Bootstrap renderer"""
        # Build DataFrame with formatted org names that include badges
        df_data = []
        for ein, row in stopped_recurring.head(max_shown).iterrows():
            # Get formatted org name with badges
            charity_info = self.format_charity_info(ein, row['Organization_Name'], row['Total_Amount'])

            df_data.append({
                'Organization': charity_info['html_org'],
                'Total Amount': f"${row['Total_Amount']:,.2f}",
                'Donations': row['Donation_Count'],
                'First Date': row['First_Date'].strftime("%m/%d/%Y"),
                'Last Date': row['Last_Date'].strftime("%m/%d/%Y")
            })

        df = pd.DataFrame(df_data)

        table = ReportTable.from_dataframe(
            df,
            title=f"Stopped Recurring Donations ({len(stopped_recurring)} organizations)"
        )
        return self.table_renderer.render(table)

    def generate_recurring_summary_section_html(self, data):
        """Generate recurring charities summary as HTML - two columns for print"""
        if data is None:
            return templates.no_recurring_charities()

        # Build DataFrame from rows
        df_data = []
        for row in data['rows']:
            last_date_str = row['last_date'].strftime('%Y-%m-%d') if row['last_date'] else 'N/A'

            # Get formatted org name with badges
            charity_info = self.format_charity_info(row['ein'], row['organization'], row['total_donated'])

            df_data.append({
                'EIN': row['ein'],
                'Organization': charity_info['html_org'],
                'Total Donated': f"${row['total_donated']:,.2f}",
                'Last Donation': last_date_str
            })

        columns_html = self._render_two_column_table(df_data)

        return templates.recurring_charities_section(
            min_years=self.recurring_min_years,
            min_amount=self.recurring_min_amount,
            count=data['count'],
            total=data['total'],
            columns_html=columns_html
        )

    def generate_csv_recurring_section_html(self, csv_recurring_df, max_shown):
        """Generate CSV-based recurring charities section as HTML"""
        if csv_recurring_df is None or csv_recurring_df.empty:
            return templates.no_csv_recurring_charities()

        display_df = csv_recurring_df.head(max_shown)
        total_amount = csv_recurring_df['Total'].sum()

        df_data = []
        for ein, row in display_df.iterrows():
            charity_info = self.format_charity_info(ein, row['Organization'], row['Total'])

            df_data.append({
                'Organization': charity_info['html_org'],
                'Total': f"${row['Total']:,.2f}",
                'Donations': int(row['Count']),
                'Years': row['Years']
            })

        table_df = pd.DataFrame(df_data)
        table = ReportTable.from_dataframe(table_df, title=None)
        table_html = self.table_renderer.render(table)

        return templates.csv_recurring_section(
            csv_count=len(csv_recurring_df),
            display_count=len(display_df),
            table_html=table_html,
            total_amount=total_amount
        )

    def generate_combined_recurring_section_html(self, combined_df, max_shown):
        """Generate combined recurring charities section as HTML.

        Combines both rule-based and CSV-based recurring charities with a Source column.
        """
        if combined_df is None or combined_df.empty:
            return """
    <div class="report-section">
        <h2 class="section-title">Recurring Charities</h2>
        <p>No recurring charities found.</p>
    </div>"""

        display_df = combined_df.head(max_shown)
        total_amount = combined_df['Total'].sum()
        total_count = len(combined_df)

        df_data = []
        for ein, row in display_df.iterrows():
            charity_info = self.format_charity_info(ein, row['Organization'], row['Total'])

            df_data.append({
                'Organization': charity_info['html_org'],
                'Total': f"${row['Total']:,.2f}",
                'Donations': int(row['Count']),
                'Years': row['Years'],
                'Source': row['Source']
            })

        table_df = pd.DataFrame(df_data)
        table = ReportTable.from_dataframe(table_df, title=None)
        table_html = self.table_renderer.render(table)

        # Count by source
        source_counts = combined_df['Source'].value_counts().to_dict()
        both_count = source_counts.get('both', 0)
        rule_only = source_counts.get('rule', 0)
        csv_only = source_counts.get('csv', 0)

        # Count stopped charities
        stopped_count = sum(1 for s in source_counts.keys() if 'stopped' in s)
        active_count = total_count - stopped_count

        breakdown = f"{both_count} in both, {rule_only} rule-based only, {csv_only} CSV-based only"
        if stopped_count > 0:
            breakdown += f", {stopped_count} stopped"

        return templates.combined_recurring_section(
            min_years=self.recurring_min_years,
            min_amount=self.recurring_min_amount,
            total_count=total_count,
            display_count=len(display_df),
            active_count=active_count,
            breakdown=breakdown,
            table_html=table_html,
            total_amount=total_amount
        )

    def generate_all_charities_section_html(self, all_charities_df, max_shown, title="All Charities", subtitle=None):
        """Generate comprehensive all charities list as HTML.

        Shows all charities with CSV/Rule indicators, years donated, current year amount, etc.

        Args:
            all_charities_df: DataFrame with charity data
            max_shown: Maximum number to display
            title: Section title (default: "All Charities")
            subtitle: Optional custom subtitle. If None, uses default based on showing_text and rule_count
        """
        if all_charities_df is None or all_charities_df.empty:
            return f"""
    <div class="report-section">
        <h2 class="section-title">{title}</h2>
        <p>No charities found.</p>
    </div>"""

        display_df = all_charities_df if max_shown is None else all_charities_df.head(max_shown)
        total_charities = len(all_charities_df)
        total_amount = all_charities_df['Total'].sum()

        # Get current year from column name
        current_year_col = [col for col in all_charities_df.columns if col.isdigit()][0]

        df_data = []
        for ein, row in display_df.iterrows():
            charity_info = self.format_charity_info(ein, row['Organization'], row['Total'])

            df_data.append({
                'EIN': ein,
                'Organization': charity_info['html_org'],
                'Total': f"${row['Total']:,.0f}",
                'Recurr': row['Rule'],
                'Count': int(row['Count']),
                'Years': row['Years'],
                'Current Year': f"${row[current_year_col]:,.0f}" if row[current_year_col] > 0 else ""
            })

        table_df = pd.DataFrame(df_data)
        table = ReportTable.from_dataframe(table_df, title=None)
        table_html = self.table_renderer.render(table)

        # Count Rule-based recurring charities
        rule_count = (all_charities_df['Rule'] == '✓').sum()

        showing_text = f"showing all {total_charities}" if max_shown is None else f"showing top {len(display_df)} of {total_charities}"

        # Generate default subtitle if not provided
        if subtitle is None:
            subtitle = f"Complete list of all charities from your donation history, ordered by total amount donated ({showing_text}). CSV and Rule columns indicate recurring status: {rule_count} meet rule-based recurring criteria (≥{self.recurring_min_years} years, ≥${self.recurring_min_amount:,}/year)."

        return templates.all_charities_section(
            title=title,
            subtitle=subtitle,
            table_html=table_html,
            total_amount=total_amount
        )

    def generate_remaining_charities_section_html(self, data):
        """Generate remaining charities section as HTML - two columns for print"""
        if data is None or data['count'] == 0:
            return ""

        # Build DataFrame from rows
        df_data = []
        for row in data['rows']:
            last_date_str = row['last_date'].strftime('%Y-%m-%d') if row['last_date'] else 'N/A'

            # Get formatted org name with badges
            charity_info = self.format_charity_info(row['ein'], row['organization'], row['total_donated'])

            df_data.append({
                'Organization': charity_info['html_org'],
                'Total Donated': f"${row['total_donated']:,.2f}",
                'Donations': row['donation_count'],
                'Years': row['unique_years']
            })

        columns_html = self._render_two_column_table(df_data)

        return templates.remaining_charities_section(
            count=data['count'],
            min_years=self.recurring_min_years,
            min_amount=self.recurring_min_amount,
            columns_html=columns_html,
            total=data['total']
        )

    def generate_charity_card_bootstrap(self, i, tax_id):
        """Generate charity detail as Bootstrap card"""
        org_donations = self.charity_details[tax_id]
        has_graph = self.graph_info.get(tax_id) is not None
        evaluation = self.charity_evaluations.get(tax_id)

        # Get description from charapi evaluation
        description = getattr(evaluation, 'summary', None) if evaluation else None
        if not description:
            description = "No description available"

        org_name = org_donations["Organization"].iloc[0] if not org_donations.empty else "Unknown"
        total_donated = org_donations["Amount_Numeric"].sum()
        donation_count = len(org_donations)

        # Get most recent donation info
        most_recent_donation = org_donations.loc[org_donations["Submit Date"].idxmax()]
        most_recent_date = most_recent_donation["Submit Date"].strftime("%b %d, %Y")
        most_recent_amount = most_recent_donation["Amount_Numeric"]

        # Get formatted org name with badges
        charity_info = self.format_charity_info(tax_id, org_name, total_donated)
        org_name_with_badges = charity_info['html_org']

        # Get tags and service areas from evaluation data
        tags = "Not specified"
        service_area = "Not specified"
        if evaluation and hasattr(evaluation, 'data_field_values'):
            tags_data = evaluation.data_field_values.get('tags', [])
            if tags_data:
                if isinstance(tags_data, list):
                    tags = ", ".join(tags_data)
                else:
                    tags = str(tags_data)

            service_areas_data = evaluation.data_field_values.get('service_areas', [])
            if service_areas_data:
                if isinstance(service_areas_data, list):
                    service_area = ", ".join(service_areas_data)
                else:
                    service_area = str(service_areas_data)

        sections = [
            CardSection(
                section_type="key_value",
                content={
                    "Tax ID": tax_id,
                    "Mission": tags,
                    "Service Area": service_area,
                    "Donations": f"${total_donated:,.0f} ({donation_count}x) | Latest: ${most_recent_amount:,.0f} on {most_recent_date}"
                }
            )
        ]

        if evaluation:
            # Calculate overall evaluation score (percentage of acceptable or better)
            total_metrics = evaluation.total_metrics
            if total_metrics > 0:
                acceptable_or_better = evaluation.outstanding_count + evaluation.acceptable_count
                eval_score = int((acceptable_or_better / total_metrics) * 100)
                eval_content = [
                    f"<strong>Overall: {eval_score}% ({acceptable_or_better}/{total_metrics})</strong>",
                    f"⭐ Outstanding: {evaluation.outstanding_count} metrics",
                    f"✓ Acceptable: {evaluation.acceptable_count} metrics",
                    f"⚠ Unacceptable: {evaluation.unacceptable_count} metrics"
                ]
            else:
                eval_content = [
                    f"⭐ Outstanding: {evaluation.outstanding_count} metrics",
                    f"✓ Acceptable: {evaluation.acceptable_count} metrics",
                    f"⚠ Unacceptable: {evaluation.unacceptable_count} metrics"
                ]

            sections.append(CardSection(
                section_type="list",
                title="Charity Evaluation:",
                content=eval_content
            ))

            if evaluation.alignment_score is not None and evaluation.alignment_score > 0:
                # Get preference metrics breakdown
                alignment_score = evaluation.alignment_score
                from charapi.data.charity_evaluation_result import MetricCategory
                preference_metrics = [m for m in evaluation.metrics if m.category == MetricCategory.PREFERENCE]

                breakdown_items = [f"<strong>Overall Score: {alignment_score}/100</strong>"]
                for metric in preference_metrics:
                    status_icon = "⭐" if metric.status.value == "outstanding" else "✓" if metric.status.value == "acceptable" else "⚠"
                    # Shorten label: "Mission Alignment" -> "Mission"
                    short_name = metric.name.replace(" Alignment", "")
                    breakdown_items.append(f"{status_icon} {short_name}: {metric.display_value}")

                sections.append(CardSection(
                    section_type="list",
                    title="Alignment with Your Goals:",
                    content=breakdown_items
                ))

            if evaluation.summary:
                sections.append(CardSection(
                    section_type="text",
                    content=evaluation.summary
                ))

        graph_filename = f"images/charity_{i:02d}_{tax_id.replace('-', '')}.png" if has_graph else None

        card = ReportCard(
            title=f"{org_name_with_badges}",
            badge=None,  # Badges are now in the title
            sections=sections,
            image_url=graph_filename,
            image_position="right"  # Right position - will need custom rendering
        )

        return self.card_renderer.render(card)

    def generate_report(self, category_totals, yearly_amounts, yearly_counts, one_time,
                       stopped_recurring, charities):
        """Generate complete HTML report using render_html_document base"""
        # Store data as instance variables for access by section handlers
        self.category_totals = category_totals
        self.yearly_amounts = yearly_amounts
        self.yearly_counts = yearly_counts
        self.one_time = one_time
        self.stopped_recurring = stopped_recurring
        self.charities = charities

        # Calculate summary statistics (precomputed to avoid duplication)
        self.total_amount = category_totals.sum()
        self.one_time_total = one_time["Total_Amount"].sum()
        self.one_time_count = len(one_time)
        self.stopped_total = stopped_recurring["Total_Amount"].sum()
        self.stopped_count = len(stopped_recurring)

        # Precompute recurring configuration (used in multiple template calls)
        pattern_config = self.config.get('recurring_charity', {}).get('pattern_based', {})
        self.recurring_min_years = pattern_config.get('min_years', 6)
        self.recurring_min_amount = pattern_config.get('min_amount', 1000)

        # Get exec section options from config
        exec_options = {}
        exec_enabled = False
        sections = self.config.get("sections", [])
        for section in sections:
            section_name = section if isinstance(section, str) else section.get("name")
            if section_name == "exec":
                exec_enabled = True
                if isinstance(section, dict):
                    section_opts = _extract_section_options(section)
                    # Check include flag: defaults to True if not specified
                    include = section_opts.get("include", True)
                    if include == False:
                        exec_enabled = False
                        break
                    exec_options = section_opts
                break

        # Generate custom header only if exec section is enabled
        custom_header = ""
        if exec_enabled:
            custom_header = self.generate_html_header_section(exec_options)

        # Generate sections HTML (excluding definitions which will be added at the end)
        sections_html = generate_table_sections(
            self.config,
            builder=self,
            exclude_definitions=True  # We'll add this manually at the end
        )

        # Check if detailed section should be included
        detailed_enabled = False
        detailed_max_shown = None
        for section in sections:
            section_name = section if isinstance(section, str) else section.get("name")
            if section_name == "detailed":
                detailed_enabled = True
                if isinstance(section, dict):
                    section_opts = _extract_section_options(section)
                    # Check include flag: defaults to True if not specified
                    include = section_opts.get("include", True)
                    if include == False:
                        detailed_enabled = False
                    # Get max_shown option
                    detailed_max_shown = section_opts.get("max_shown")
                break

        # Generate charity cards section only if enabled
        charity_cards_html = ""
        if detailed_enabled:
            # Determine how many charities to show
            charities_to_show = charities.head(detailed_max_shown) if detailed_max_shown else charities
            num_shown = len(charities_to_show)
            total_charities = len(charities)

            # Update title based on whether we're limiting or showing all
            if detailed_max_shown and num_shown < total_charities:
                title_text = f"Detailed Analysis ({num_shown} of {total_charities} charities)"
            else:
                title_text = f"Detailed Analysis ({num_shown} charities)"

            charity_cards_html = f"""
    <div class="report-section section-detailed">
        <h2 class="section-title">{title_text}</h2>
        <p>Complete donation history and trend analysis for each charity:</p>
"""
            for i, (tax_id, _) in enumerate(charities_to_show.iterrows(), 1):
                charity_cards_html += self.generate_charity_card_bootstrap(i, tax_id)
            charity_cards_html += "\n    </div>"

        # Check if definitions section should be included
        definitions_enabled = False
        for section in sections:
            section_name = section if isinstance(section, str) else section.get("name")
            if section_name == "definitions":
                definitions_enabled = True
                if isinstance(section, dict):
                    section_opts = _extract_section_options(section)
                    # Check include flag: defaults to True if not specified
                    include = section_opts.get("include", True)
                    if include == False:
                        definitions_enabled = False
                break

        # Generate definitions section (at the very end) only if enabled
        definitions_html = ""
        if definitions_enabled:
            definitions_html = generate_definitions_section()

        # Combine body content: sections + charity cards + definitions
        body_content = f"{sections_html}\n{charity_cards_html}\n{definitions_html}"

        # Generate footer
        custom_footer = """
    <footer class="mt-5 pt-3 border-top text-center text-muted">
        <small>Generated by fidchar donation analysis tool</small>
    </footer>"""

        # External CSS files - all styles consolidated into styles.css
        # colors.css: Color definitions (minimal, mostly empty)
        # styles.css: All screen and print styles (includes @media print section)

        # Build complete HTML document
        html_content = self._build_html_document(
            custom_header=custom_header + body_content,
            custom_footer=custom_footer
        )

        # Get output directory from config
        output_dir = self.config.get("output_dir", "output")

        # Copy CSS files to output directory
        for css_file in ["colors.css", "styles.css"]:
            css_source = os.path.join(os.path.dirname(__file__), css_file)
            css_dest = os.path.join(output_dir, css_file)
            shutil.copy(css_source, css_dest)

        html_file_path = os.path.join(output_dir, "donation_analysis.html")
        with open(html_file_path, "w") as f:
            f.write(html_content)


# Helper functions for section generation

def _add_section_class(html: str, section_name: str) -> str:
    """Add a specific section CSS class to HTML."""
    return html.replace('class="report-section"', f'class="report-section section-{section_name}"', 1)


def _handle_sectors(builder, section_options):
    """Generate sectors section with categories and yearly graphs."""
    show_percentages = section_options.get("show_percentages", False)
    categories_html = builder.generate_category_table_bootstrap(
        builder.category_totals,
        builder.total_amount,
        show_percentages
    )

    return templates.sectors_section(categories_html=categories_html)


def _handle_yearly(builder, _section_options):
    """Generate yearly table section."""
    yearly_html = builder.generate_yearly_table_bootstrap(
        builder.yearly_amounts,
        builder.yearly_counts
    )
    return templates.yearly_section(yearly_html=yearly_html)


def _handle_top_charities(builder, section_options):
    """Generate charities section."""
    max_shown = section_options.get("max_shown", None)
    charities_to_show = builder.charities.head(max_shown) if max_shown else builder.charities
    charities_html = builder.generate_top_charities_bootstrap(charities_to_show)
    return templates.top_charities_section(top_charities_html=charities_html)


def _create_high_alignment_filter(min_alignment: int):
    """Create filter function for high-alignment non-recurring charities.

    Args:
        min_alignment: Minimum alignment score threshold (e.g., 80)

    Returns:
        Filter function that takes (ein, in_csv, in_rule, evaluation) -> bool
    """
    def filter_high_alignment_non_recurring(_ein, _in_csv, in_rule, evaluation):
        # Must NOT be rule-based recurring
        if in_rule:
            return False
        # Must have evaluation with alignment score >= threshold
        if evaluation and hasattr(evaluation, 'alignment_score'):
            return evaluation.alignment_score >= min_alignment
        return False

    return filter_high_alignment_non_recurring


def _handle_patterns(builder, section_options):
    """Generate Patterns section."""
    max_one_time = section_options.get("max_one_time_shown", 20)
    max_stopped = section_options.get("max_stopped_shown", 15)

    one_time_table = builder.generate_one_time_table_bootstrap(builder.one_time, max_shown=max_one_time)
    overflow_one_time = max(0, builder.one_time_count - max_one_time)

    stopped_table = builder.generate_stopped_table_bootstrap(builder.stopped_recurring, max_shown=max_stopped)
    overflow_stopped = max(0, builder.stopped_count - max_stopped)

    return templates.patterns_section(
        one_time_table=one_time_table,
        one_time_total=builder.one_time_total,
        one_time_overflow=overflow_one_time,
        stopped_table=stopped_table,
        stopped_total=builder.stopped_total,
        stopped_overflow=overflow_stopped
    )


def _handle_recurring_summary(builder, section_options):
    """Generate Recurring Summary section."""
    max_recurring = section_options.get("max_recurring_shown", 20)
    data = builder.prepare_recurring_summary_data(max_shown=max_recurring)
    summary_html = builder.generate_recurring_summary_section_html(data)
    return _add_section_class(summary_html, "recurring-summary")


def _handle_csv_recurring(builder, section_options, csv_recurring_df):
    """Generate CSV Recurring section."""
    max_shown = section_options.get("max_shown", 100)
    csv_html = builder.generate_csv_recurring_section_html(csv_recurring_df, max_shown)
    return _add_section_class(csv_html, "csv-recurring")


def _handle_combined_recurring(builder, section_options, csv_recurring_df):
    """Generate Combined Recurring section."""
    max_shown = section_options.get("max_shown", 100)
    combined_df = builder.prepare_combined_recurring_data(csv_recurring_df, max_shown)
    combined_html = builder.generate_combined_recurring_section_html(combined_df, max_shown)
    return _add_section_class(combined_html, "combined-recurring")


def _handle_remaining(builder, section_options):
    """Generate Remaining Charities section."""
    max_remaining = section_options.get("max_remaining_shown", 100)
    data = builder.prepare_remaining_charities_data(builder.one_time, builder.charities, max_shown=max_remaining)
    remaining_html = builder.generate_remaining_charities_section_html(data)
    return _add_section_class(remaining_html, "remaining")


def _handle_all_charities(builder, section_options, csv_recurring_df):
    """Generate All Charities section."""
    max_shown = section_options.get("max_shown", None)
    all_charities_df = builder.prepare_all_charities_data(csv_recurring_df, max_shown)
    all_charities_html = builder.generate_all_charities_section_html(all_charities_df, max_shown)
    return _add_section_class(all_charities_html, "all-charities")


def _handle_high_alignment_opportunities(builder, section_options, csv_recurring_df):
    """Generate High Alignment Opportunities section."""
    max_shown = section_options.get("max_shown", None)
    min_alignment = section_options.get("min_alignment_score", 80)

    filter_func = _create_high_alignment_filter(min_alignment)
    opportunities_df = builder.prepare_all_charities_data(
        csv_recurring_df, max_shown, filter_func=filter_func
    )

    # Create custom subtitle for high alignment opportunities
    total_count = len(opportunities_df) if opportunities_df is not None and not opportunities_df.empty else 0
    showing_text = f"showing all {total_count}" if max_shown is None else f"showing top {min(max_shown, total_count)} of {total_count}"
    subtitle = f"High-quality charities with ≥{min_alignment}% alignment that are not currently recurring donations ({showing_text}). These represent potential candidates for recurring support."

    opportunities_html = builder.generate_all_charities_section_html(
        opportunities_df, max_shown,
        title=f"High Alignment Opportunities",
        subtitle=subtitle
    )
    return _add_section_class(opportunities_html, "high-alignment")


def generate_table_sections(config: dict, builder=None, exclude_definitions=False):
    """Generate all report sections based on configuration.

    This function dispatches to specialized handlers for each section type.
    All handlers access data through the builder instance.
    """
    sections = config.get("sections", {})
    html_content = ""

    # Compute csv_recurring_df once (used by multiple sections)
    csv_recurring_df = None
    if builder:
        csv_recurring_df = an.get_csv_recurring_details(builder.df)

    for section in sections:
        section_id = section if isinstance(section, str) else section.get("name")

        # Skip definitions if we're excluding it (will be added manually at the end)
        if exclude_definitions and section_id == "definitions":
            continue

        section_options = _extract_section_options(section)

        # Check include flag: defaults to True if not specified
        # include: true  -> include section
        # include: false -> skip section
        # (no include)   -> include section (default)
        include = section_options.get("include", True)
        if include == False:
            continue

        # All sections now use handlers
        if builder:
            # Create handler map with closures capturing needed variables
            handlers = {
                "sectors": lambda: _handle_sectors(builder, section_options),
                "yearly": lambda: _handle_yearly(builder, section_options),
                "top_charities": lambda: _handle_top_charities(builder, section_options),
                "patterns": lambda: _handle_patterns(builder, section_options),
                "recurring_summary": lambda: _handle_recurring_summary(builder, section_options),
                "csv_recurring": lambda: _handle_csv_recurring(builder, section_options, csv_recurring_df),
                "combined_recurring": lambda: _handle_combined_recurring(builder, section_options, csv_recurring_df),
                "remaining": lambda: _handle_remaining(builder, section_options),
                "all_charities": lambda: _handle_all_charities(builder, section_options, csv_recurring_df),
                "high_alignment_opportunities": lambda: _handle_high_alignment_opportunities(builder, section_options, csv_recurring_df),
            }

            handler = handlers.get(section_id)
            if handler:
                html_content += handler()

    return html_content


def generate_definitions_section():
    """Generate the definitions section from markdown file"""
    import os
    from markdown_it import MarkdownIt

    md = MarkdownIt()
    definitions_path = os.path.join(os.path.dirname(__file__), "..", "definitions.md")

    try:
        with open(definitions_path, "r") as f:
            markdown_content = f.read()

        # Process magic strings for column layout
        markdown_content = markdown_content.replace(
            ':begin-left',
            '<div class="row border-bottom">\n<div class="col-md-6 border-end border-dark">'
        )
        markdown_content = markdown_content.replace(':end-left', '</div>')
        markdown_content = markdown_content.replace(':begin-right', '<div class="col-md-6">')
        markdown_content = markdown_content.replace(':end-right', '</div>\n</div>')

        html_definitions = md.render(markdown_content)
        
        return f"""
    <div class="report-section section-definitions">
        {html_definitions}
    </div>"""
            
    except FileNotFoundError:
        return """
    <div class="report-section section-definitions">
        <h2 class="section-title">Definitions</h2>
        <p><em>Definitions file not found.</em></p>
    </div>"""